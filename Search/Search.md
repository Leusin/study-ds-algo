# 1. 탐색 알고리즘 개요

탐색(Search)이란 주어진 데이터 구조(배열, 트리, 그래프 등)에서 특정한 값을 찾거나, 원하는 목표 상태에 도달하는 과정을 의미합니다. 탐색 알고리즘은 크게 기본적인 데이터 검색과 경로 탐색 전략으로 나뉘며, 탐색 방법에 따라 다양한 기법이 존재합니다.

## (1) 기본 탐색 알고리즘

### [1] 선형 탐색(Linear Search)

*순차 검색, sequential search*

- **시간 복잡도**: $O(N)$
- **공간 복잡도**: $O(1)$
- **응용**: 기준보다 크거나 작은 데이터 집합 찾기, 링크드 리스트 검색
- **설명**: 배열이나 목록의 각 요소를 처음부터 끝까지 하나씩 비교하여 대상 요소를 찾습니다. 목록의 끝에 도달할 때까지 일치하는 항목을 찾지 못하면, 대상 요소는 배열에 없다고 판단합니다.
- **평가**: 배열이 정렬되지 않아도 사용 가능하고, 모든 데이터 유형에서 사용할 수 있으며, 추가적인 메모리가 필요하지 않습니다.

### [2] 이진 탐색(Binary Search)

- **시간 복잡도**: $O(\log N)$
- **공간 복잡도**: $O(1)$
- **응용**: 머신 러닝의 하이퍼 파리마터 최적화, 신경망 학습 알고리즘, 그래픽스의 레이트레이싱 및 텍스처 매핑 알고리즘 활용, 데이터베이스 검색
- **설명**: 정렬된 배열에서 중간 값을 기준으로 값을 비교하며 탐색 범위를 절반씩 좁혀가는 알고리즘입니다. 탐색할 배열이 정렬되어 있어야 합니다. 반복적 또는 재귀적인 방법으로 구현할 수 있습니다.
- **평가**: 선형 탐색보다 효율적이며, 특히 데이터의 크기가 클 경우 성능 차이가 두드러집니다. 하지만 이진 탐색은 반드시 정렬된 배열에서만 동작하므로, 정렬된 상태를 유지하는 추가 작업이 필요하며, 자료 구조의 형태가 메모리 공간에 저장되어야 합니다.

## (2) 비정보 탐색(Uninformed Search)

*맹목적 탐색, blind search algorithms*

문제에서 추가 지식이 없는 상태에서 경로를 탐색 또는 정보 검색을 위한 전략입니다.

### [1] 너비 우선 탐색(BFS, Breadth-First Search)

- **시간 복잡도**: $O(V+E)$ (V: 정점 수, E: 간선 수)
- **공간 복잡도**: $O(V)$
- **응용**: 다익스트라 알고리즘(Dijkstra Algorithm), 위상 정렬(Kahn's Algorithm), 최소 신장 트리(Prim's Algorithm) 등 다양한 그래프 알고리즘의 기반이 됩니다.
- **설명**:  BFS는 그래프를 순회하는 기본적인 알고리즘으로, 시작 정점에서 가까운 정점부터 차례로 탐색합니다.
    
    그래프 순회 알고리즘입니다. 시작 정점에서 시작하여 큐에 넣고 방문한 것으로 표시합니다. 큐(Queue)를 활용하여 정점을 방문하고, 방문한 정점의 이웃을 차례로 큐에 넣으며 큐가 비어 있을 때까지 반복 진행합니다.
    
- **평가**: BFS는 가중치 없는 그래프의 최단 경로 탐색에서 유용하며, 탐색 목표가 시작 정점(루트 노드)에 가까울 수록 유용합니다. 하지만 큐에 방문한 노드를 저장하므로, 노드 수가 많아질수록  메모리 사용량이 많을 수 있습니다.

### [2] 깊이 우선 탐색(DFS, Depth-First Search)

- **시간 복잡도**: $O(V+E)$ (V: 정점 수, E: 간선 수)
- **공간 복잡도**: $O(V+E)$
- **응용**: 그래프의 연결 요소 찾기, 사이클 검출, 위상 정렬, 경로 탐색 등 다양한 그래프 문제 해결에 사용됩니다.
- **설명**: 그래프를 탐색할 때 가능한 한 깊게 들어가면서 탐색하는 방식입니다. 시작 정점에서 인접한 정점으로 이동하며, 더 이상 갈 곳이 없으면 돌아가서 다른 인접 정점을 탐색합니다. 이때 탐색 순서는 스택을 사용해 구현하거나, 재귀적으로 호출하여 구현할 수 있습니다.
- **평가**: 그래프 또는 트리가 크지 않을 때 유용합니다. 최단 경로를 보장하지 않으며, 탐색 목표가 시작 정점(루트 노드) 가까이 있어도 처음 탐색하는 하위 노드에 위치하지 않는다면 해당 노드에 매우 늦게 도달합니다.

### [3] 반복 깊이 증가 탐색(Iterative Deepening DFS, IDDFS)

- **시간 복잡도**: $O(b^d)$ (b: 자식 노드, d: 깊이)
- **공간 복잡도**: $O(d)$
- **응용**: 메모리 효율적인 그래프 탐색, 네트워크 라우팅 알고리즘, 경로 탐색, 게임 AI 구현
- **설명**: DFS를 일정한 깊이 제한을 두고 반복적으로 수행하여 BFS와 유사한 탐색 결과를 얻는 방식입니다. 깊이 제한을 1부터 증가시키며 DFS를 실행하고, 목표 노드가 발견되면 탐색을 종료합니다.
- **평가**: 메모리 사용이 적고, 각 단계에서 DFS를 반복 실행하기 때문에 이론적으로 비효율적으로 보일 수 있으나, 대부분의 경우 중복된 탐색이 적어 성능 저하가 크지 않습니다.

### [4] 균일 비용 탐색(Uniform Cost Search, UCS)

- **시간 복잡도**: $O((V+E) \log V)$ (V: 정점 수, E: 간선 수)
- **공간 복잡도**: $O(V+E)$
- **응용**: 네트워크 라우팅, AI 경로 탐색 등 가중치가 있는 그래프의 최단 경로 탐색.
- **설명**: 다익스트라 알고리즘과 유사하지만, 목표 노드를 찾으면 즉시 종료하여 불필요한 탐색을 줄일 수 있습니다. 비용이 낮은 정점부터 확장하며, 우선순위 큐를 사용하여 현재까지의 최저 비용 경로를 유지합니다.
- **평가**: 최적 해를 보장하며, 목표 노드가 가까운 경우 다익스트라보다 효율적일 수 있습니다. 그러나 상태 공간이 많아질 경우, 우선순위 큐의 크기가 커져 성능이 저하될 수 있습니다.

## (3) 정보 탐색(Informed Search)

*휴리스틱 탐색, heuristic search*

문제에서 얻을 수 있는 추가적인 정보를 더 효율적으로 문제를 해결하는데 사용할 수 있는 전략입니다. 이러한 정보는 일반적으로 허용 추정치 함수(Heuristic Function)를 통해 얻습니다.

### [1] 탐욕적 최적 우선탐색(Greedy Best-First Search, GBFS)

- **시간 복잡도**: $O((V+E)\log V)$ (V: 정점 수, E: 간선 수)
- **공간 복잡도**: $O(V+E)$
- **응용**: 길찾기, 기계 학습, 최적화, 게임 AI, 자연어 처리, 이미지 처리
- **설명**: 휴리스틱 함수를 사용하여 목표까지의 추정 비용을 평가한 후, 가장 유망한 노드를 선택합니다. 이 과정은 목표에 도달할 때까지 반복되며, 지나온 경로의 실제 비용은 고려하지 않습니다.
- **평가**: BFS는 간단하고 구현이 쉬우며 메모리 요구량이 적다는 장점이 있습니다. 하지만 최적해를 보장하지 않으며, 지역 최적해(local optimum)에 빠질 가능성이 있습니다.

### [2] A* 알고리즘(A* Algorithm)

- **시간 복잡도**: $O(E)$ (E: 간선 수)
- **공간 복잡도**: $O(V)$ (V: 정점 수)
- **응용**: 게임 및 웹 기반 지도 길찾기
- **설명**: 최단 경로를 찾기 위해 휴리스틱 정보를 활용하는 탐색 알고리즘입니다. 단순한 너비 우선 탐색(BFS)이나 다익스트라 알고리즘과 달리, 목표 지점까지의 예상 비용을 고려하여 보다 효율적인 탐색을 수행합니다. 이를 위해 실제 이동 비용(g)과 추정 비용(h)의 합인 평가 함수 $f(n) = g(n) + h(n)$을 사용하여 가장 유망한 경로를 우선 탐색합니다.
- **평가**: 최적 경로 탐색에 효과적이며, 다익스트라보다 빠를 수 있지만, 휴리스틱 함수의 품질에 따라 성능과 정확성이 크게 달라질 수 있어 항상 최단 경로를 생성하지는 않습니다.

### [3] 반복 깊이 증가 A*(Iterative Deepening A*, IDA*)

- **시간 복잡도**: $O(b^d)$ (b: 분기 계수, d: 깊이)
- **공간 복잡도**: $O(d)$
- **응용**: 메모리가 제한되어 있는 AI 문제를 해결
- **설명**: IDA는 최단 경로를 찾는 휴리스틱 기반 탐색 알고리즘으로, A*와 반복적 심화 탐색(IDDFS)의 개념을 결합한 방식 입니다. 임계값 내에서 가능한 모든 노드를 탐색하는 A*와 달리 IDA는 휴리스틱 함수를 사용해 가장 유망한 노드를 평가하고 우선순위를 지정합니다.
- 평가: A*와 동일한 최적 해를 보장하지만, 중복 탐색으로 실행 시간이 더 길 수 있습니다.

# # 참고

- [탐색 알고리즘 - 나무위키](https://namu.wiki/w/%ED%83%90%EC%83%89%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
- [Searching Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/searching-algorithms/)
- [Uninformed Search Algorithms in AI - GeeksforGeeks](https://www.geeksforgeeks.org/uniformed-search-algorithms-in-ai/)
- [Informed Search Algorithms in Artificial Intelligence - GeeksforGeeks](https://www.geeksforgeeks.org/informed-search-algorithms-in-artificial-intelligence/)