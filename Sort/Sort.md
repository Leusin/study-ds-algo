# 1. 정렬의 주요 개념

정렬(Sorting)이란 데이터를 일정한 순서로 배열하는 과정입니다. 

## (1) 순서 관계(ordering relation)

정렬을 수행하려면 비교할 기준이 필요합니다. 숫자의 경우 크기, 문자열의 경우 사전 순서 등이 기준이 될 수 있습니다. 즉, 두 요소 간 관계는 명확해야 하며, 관계가 모호하면 정렬을 수행할 수 없습니다.

### [1] 삼분법(Law of Trichotomy)

수학에서 삼분법은 임의의 요소  $a$, $b$ 에 대해 다음 세 가지 관계 중 오직 하나만 성립해야 한다는 원칙입니다.

- $a<b$
- $a=b$
- $a>b$

즉, 두 요소 간 관계는 반드시 명확해야 하며, 이 관계가 모호하면 정렬을 정의할 수 없습니다.

### [2] 전이 법칙(Law of Transitivity)

순서 관계가 일관성을 가져야 한다는 원칙입니다.

- $a<b$ 이고,
- $b<c$ 라면,
- 반드시 $a<c$ 가 성립해야 한다.

이 법칙이 성립하지 않으면 정렬의 일관성이 보장되지 않습니다.

## (2) 반전(inversions)

정렬에서 반전은 배열이 얼마나 정렬되지 않았는지를 측정하는 개념입니다. 배열에서 앞 요소가 뒤 요소보다 큰 경우 이를 반전이라고 합니다. 

배열 [3, 1, 2] 를 오름차순으로 정렬해야 한다고 할 때, (3, 1)와 (3, 2)는 반전 관계입니다.

정렬 알고리즘은 이러한 이러한 반전 개수를 줄여가는 방식으로 동작합니다.

## (3) 안정성(stability)

정렬에서의 안정성은 동일한 값을 가진 요소들이 정렬 후에도 기존의 상대적 순서를 유지하는 성질을 의미합니다.

> A(90), B (80), C (90), D(70)
> 

위와 같은 데이터가 있다고 가정할 하고 숫자를 기준으로 오름차순으로 정렬할 때 안정적인 정렬이라면 아래 정렬처럼 기존의 순서가 유지됩니다.

> D (70), B (80), A (90), C (90)
> 

다음과 배열 역시 점수를 기준으로 정렬을 한 모습입니다.

> D(70), B (80), C (90), A (90)
> 

 C(90) 와 A(90)는 동일한 값을 가졌지만 A, C 의 기존 순서가 유지되지 않았기 때문에 안정적이지 않은 정렬입니다.

# 2. 주요 정렬 알고리즘

## (1)비교 정렬 알고리즘

데이터 간의 상대적 크기 관계를 이용해 정렬하는 알고리즘입니다.

### [1] 선택 정렬(Selection Sort)

- **시간 복잡도**: $O(N^2)$
- **공간 복잡도**: $O(1)$
- **안정성**: X
- **설명**: 선택 정렬은 목록의 정렬되지 않은 최소값(또는 최대값)을 차례대로 탐색한 뒤 교환하는 과정을 반복합니다.
- **평가**: 구현이 매우 직관적이고 교환 횟수가 적지만, 안정적이지 않고 성능이 좋지 않습니다.

### [2] 거품 정렬(Bubble Sort)

- **시간 복잡도**: $O(N^2)$
- **공간 복잡도**: $O(1)$
- **안정성**: O
- **설명**: 인접한 두 요소를 비교하여 필요한 경우 위치를 교환하는 과정을 반복합니다.
- **평가**: 구현이 매우 간단하고 안정적이지만, 대부분의 입력에 대해 상당히 느리기 때문에 실제로는 거의 사용되지 않습니다.

### [3] 삽입 정렬(Insertion Sort)

- **시간 복잡도**: 최선 $O(N), 최악 $O(N^2)$
- **공간 복잡도**: $O(1)$
- **안정성**: O
- **설명**: 배열의 모든 요소를 앞부분 부터 차례대로 이미 정렬된 배열 부분과 비교하여, 정렬되지 않은 요소를 적절한 위치에 삽입하는 방식으로 동작합니다.
- **평가**: 대부분의 입력에 대해 비효율적이지만, 요소가 거의 정렬되어 있는 경우에는 효율적으로 동작합니다.

### [4] 병합 정렬(Merge Sort)

- **시간 복잡도**: $O(N\log N)$
- **공간 복잡도**: $O(N)$
- **안정성**: O
- **설명**: 분할 정복 방식을 사용하여 배열을 반으로 나눈 후, 각각을 정렬하고 병합하는 방식으로 동작합니다.
- **평가**: 안정적이며 시간 복잡도가 일정하게 유지되지만, 추가적인 메모리 공간이 필요하다는 단점이 있습니다.

### [5] 퀵 정렬(Quick Sort)

- **시간 복잡도**: 평균 $O(N\log N)$, 최악 $O(N^2)$
- **공간 복잡도**: $O(\log N)$ (재귀 호출 스택 사용)
- **안정성**: X
- **설명**: 기준 원소(Pivot)를 선택하여 작은 값과 큰 값으로 나누는 과정을 반복하여 정렬하는 방식입니다.
- **평가**: 평균적으로 매우 빠른 알고리즘이지만, 최악의 경우 $O(N^2)$이 될 수 있어 적절한 기준 원소 선택이 중요합니다.

### [6] 힙 정렬(Heap Sort)

- **시간 복잡도**: $O(N\log N)$
- **공간 복잡도**: $O(1)$
- **안정성**: X
- **설명**: 힙 자료구조를 이용하여 최대(혹은 최소) 힙을 구성한 후, 최댓값(최솟값)을 하나씩 추출하여 정렬하는 방식입니다.
- **평가**: 추가 메모리를 거의 사용하지 않지만, 캐시 친화적이지 않아 실질적인 성능이 다소 저하될 수 있습니다.

## (3) 비교가 아닌 정렬 알고리즘

데이터끼리 직접적인 비교를 하지 않고 특정한 방식으로 정렬하는 알고리즘입니다. 데이터의 정렬에 따라 비교 정렬 알고리즘보다 더 작은 시간 복잡도로 정렬이 가능합니다.

### [1] 계수 정렬(Counting Sort)

- **시간 복잡도**: $O(N + K)$ ($K$: 숫자 범위)
- **공간 복잡도**: $O(K)$
- **안정성**: O
- **설명**: 각 숫자의 빈도를 세어 정렬하는 방식으로, 정수형 데이터에만 적용할 수 있습니다.
- **평가**: 특정 범위의 정수에 대해서 매우 빠르지만, 메모리 사용량이 많아질 수 있습니다. 값의 범위($K$)가 입력 크기($N$)보다 클 경우, 실제로 성능이 더 나빠질 수 있습니다.

### [2] 기수 정렬(Radix Sort)

- **시간 복잡도**: $O(NK)$ ($K$: 숫자 범위, $W$: 자릿수)
- **공간 복잡도**: $O(W(N + K))$
- **안정성**: O
- **설명**: 숫자의 자릿수를 기준으로 최하위 숫자(또는 최상위 숫자)부터 차례대로 정렬하는 알고리즘으로, 자릿수 별로 정렬을 반복하여 최종 정렬을 수행합니다.
- **평가**: 비교 연산이 없기 때문에 큰 정수나 문자열 정렬에 유용하지만, 추가적인 메모리 공간이 필요합니다.

### [3] 버킷 정렬(Bucket Sort)

- **시간 복잡도**: 평균 $O(N + K)$, 최악 $O(N^2)$ ($K$: 버킷 수)
- **공간 복잡도**: $O(NK)$
- **안정성**: O
- **설명**: 데이터를 여러 개의 버킷에 나눈 후, 각 버킷을 개별적으로 정렬하여 합치는 방식입니다.
- **평가**: 원소가 균일한 분포를 가진 데이터에 대해서는 매우 빠르지만, 적절한 버킷 개수와 정렬 방법을 선택하는 것이 중요합니다.

---

# 참고

- [Detailed Explanation of Sorting - LeetCode](https://leetcode.com/explore/learn/card/sorting/693/introduction/)
- [10 Sorting Algorithms Easily Explained - YouTube](https://www.youtube.com/watch?v=rbbTd-gkajw&list=LL&index=7)
- [정렬 알고리즘 - 나무위키](https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)